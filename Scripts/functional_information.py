# -*- coding: utf-8 -*-
"""functional information.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Gk60AGH4BrO4-gBCOi3PDpjUREqHk8QO
"""

# Script: functional information.py
# Description:
#Reads the organisms and pathways files, extracts functional information
#of the selected taxa and extracts enzymes involved in the metabolic pathways of interest
#and extracts a table with common EC numbers and respective taxonomic assignment


import requests
import pandas as pd
from collections import defaultdict

def read_pathway_ids(file_path):
    with open(file_path, 'r') as f:
        return [line.strip() for line in f if line.strip()]

def get_ecs_for_pathway(pathway_id):
    """Tries to obtain ECs directly, if it does not exist, uses KOs and converts to ECs."""
    url_ec = f"https://rest.kegg.jp/link/enzyme/{pathway_id}"
    response_ec = requests.get(url_ec)
    if response_ec.status_code == 200 and response_ec.text.strip():
        return [line.split("\t")[1].split(":")[1] for line in response_ec.text.strip().split("\n")]

    # fallback to KO → EC
    url_ko = f"https://rest.kegg.jp/link/ko/{pathway_id}"
    response_ko = requests.get(url_ko)
    if response_ko.status_code != 200 or not response_ko.text.strip():
        return []

    ko_ids = [line.split("\t")[1].split(":")[1] for line in response_ko.text.strip().split("\n")]

    ec_set = set()
    for ko in ko_ids:
        url_ko_ec = f"https://rest.kegg.jp/link/enzyme/ko:{ko}"
        response_ko_ec = requests.get(url_ko_ec)
        if response_ko_ec.status_code == 200 and response_ko_ec.text.strip():
            for line in response_ko_ec.text.strip().split("\n"):
                ec = line.split("\t")[1].split(":")[1]
                ec_set.add(ec)
    return sorted(ec_set)

def get_pathway_name(pathway_id):
    url = f"https://rest.kegg.jp/get/{pathway_id}"
    response = requests.get(url)
    if response.status_code != 200:
        return ""
    for line in response.text.split("\n"):
        if line.startswith("NAME"):
            return line.replace("NAME", "").strip()
    return ""

def get_kegg_organism_list():
    url = "https://rest.kegg.jp/list/organism"
    response = requests.get(url)
    if response.status_code != 200:
        print("❌ Failed to retrieve KEGG organism list.")
        return {}

    organism_dict = {}
    for line in response.text.strip().split("\n"):
        parts = line.split("\t")
        if len(parts) >= 3:
            kegg_code = parts[1]
            name = parts[2].split(",")[0].lower()
            organism_dict[name] = kegg_code
    return organism_dict

def find_kegg_code(genus, species, organism_dict):
    full_name = f"{genus} {species}".lower().strip()
    genus = genus.lower().strip()

    # Tries to match the name of the taxa (Genus + Species)
    for name, code in organism_dict.items():
        if full_name == name or full_name in name:
            return code

    # Tries to match just the Genus
    for name, code in organism_dict.items():
        if genus in name.split():
            return code

    return None

def get_ec_numbers_for_organism(kegg_code):
    url = f"http://rest.kegg.jp/link/enzyme/{kegg_code}"
    response = requests.get(url)
    if response.status_code != 200 or not response.text.strip():
        return []
    return sorted(set(line.split("\t")[1].split(":")[1] for line in response.text.strip().split("\n")))


def process_organisms(file_path, sep=","):
    df = pd.read_csv(file_path, sep=sep)
    if 'Genus' not in df.columns or 'Species' not in df.columns:
        raise ValueError("Input file must contain 'Genus' and 'Species' columns.")

    organism_dict = get_kegg_organism_list()
    results = []

    for _, row in df.iterrows():
        genus = str(row['Genus'])
        species = str(row['Species']) if pd.notnull(row['Species']) else ""
        organism_name = f"{genus} {species}".strip()

        kegg_code = find_kegg_code(genus, species, organism_dict)
        if kegg_code:
            ec_numbers = get_ec_numbers_for_organism(kegg_code)
        else:
            ec_numbers = []

        results.append({
            "Organism": organism_name,
            "KEGG Code": kegg_code if kegg_code else "Not found",
            "EC Count": len(ec_numbers),
            "EC Numbers": "; ".join(ec_numbers) if ec_numbers else "None"
        })

    return pd.DataFrame(results)

def map_pathways_to_ecs(pathway_ids):
    ec_to_pathways = defaultdict(list)
    for pid in pathway_ids:
        ecs = get_ecs_for_pathway(pid)
        pname = get_pathway_name(pid)
        for ec in ecs:
            ec_to_pathways[ec].append((pid, pname))
    return ec_to_pathways

def build_compatibility_table(ec_df, ec_to_pathways):
    output_rows = []
    for ec in ec_df.index:
        if ec in ec_to_pathways:
            for sample in ec_df.columns:
                if ec_df.at[ec, sample] > 0:
                    for pid, pname in ec_to_pathways[ec]:
                        output_rows.append([sample, ec, pid, pname])
    return pd.DataFrame(output_rows, columns=["Bacterium", "EC Number", "Pathway ID", "Pathway Name"])

def add_enzyme_names(compat_table):
    from functools import lru_cache

    @lru_cache(maxsize=None)
    def get_enzyme_name(ec_number):
        url = f"https://rest.kegg.jp/get/ec:{ec_number}"
        response = requests.get(url)
        if response.status_code != 200 or not response.text:
            return "Unknown"
        for line in response.text.split("\n"):
            if line.startswith("NAME"):
                return line.replace("NAME", "").strip().split(";")[0]
        return "Unknown"

    # Get unique ECs and map to enzyme names
    unique_ecs = compat_table["EC Number"].unique()
    ec_to_name = {ec: get_enzyme_name(ec) for ec in unique_ecs}

    # Add new column to DataFrame
    compat_table["Enzyme Name"] = compat_table["EC Number"].map(ec_to_name)

    return compat_table

def main(pathway_file, organisms_file, sep=","):
    # 1. Read Pathways IDs
    print("Reading the IDs of the metabolic pathways...")
    pathway_ids = read_pathway_ids(pathway_file)
    print(f"{len(pathway_ids)} pathways uploaded.")

    # 2. Mapp ECs to pathways
    print("Mapping EC numbers to pathways...")
    ec_to_pathways = map_pathways_to_ecs(pathway_ids)
    print(f"Mapping EC to {len(ec_to_pathways)} pathways.")

    # 3. Process list of organisms
    print("Processing list of organisms...")
    df_organisms = process_organisms(organisms_file, sep=sep)
    print(f"{len(df_organisms)} organisms processed.")

    # 4. Construct a compatibility matrix
    print("Constructing matrix between the ECs for each organism...")
    ec_lists = df_organisms["EC Numbers"].apply(lambda x: x.split("; ") if x != "None" else [])
    all_ecs = sorted(set(ec for sublist in ec_lists for ec in sublist))

    ec_df = pd.DataFrame(0, index=all_ecs, columns=df_organisms["Organism"])

    for i, ecs in enumerate(ec_lists):
        organism = df_organisms.at[i, "Organism"]
        for ec in ecs:
            ec_df.at[ec, organism] = 1

    # 5. Construct compatability table
    print("Constructing compatibility table between the ECs from the bacteria and pathways...")
    compat_table = build_compatibility_table(ec_df, ec_to_pathways)
    print(f"Compatibility table created with {len(compat_table)} rows.")

    return compat_table, df_organisms

if __name__ == "__main__":
    pathway_file = "pathway_ids.txt"
    organisms_file = "organisms.csv"

    compat_table, organisms_info = main(pathway_file, organisms_file)
    compat_table = add_enzyme_names(compat_table)

    compat_table.to_csv("compatibility_table_with_names.csv", index=False)